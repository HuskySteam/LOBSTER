export namespace Benchmark {
  export interface Challenge {
    name: string
    description: string
    files: Record<string, string>
    test: string
  }

  export const challenges: Challenge[] = [
    {
      name: "service-user-normalization",
      description:
        "Fix user creation flow across domain/service files. New users must have normalized IDs, trimmed display names, and lowercase emails.",
      files: {
        "package.json": `{"name":"bench-user-normalization","private":true,"type":"module"}`,
        "src/domain/user.ts": [
          `export type UserRole = "admin" | "member"`,
          ``,
          `export type UserInput = {`,
          `  name: string`,
          `  email: string`,
          `  role?: UserRole`,
          `}`,
          ``,
          `export type User = {`,
          `  id: string`,
          `  name: string`,
          `  email: string`,
          `  role: UserRole`,
          `}`,
          ``,
          `export function userIdFromName(name: string): string {`,
          `  return name.toLowerCase().replace(/\\s+/g, "-")`,
          `}`,
          ``,
        ].join("\n"),
        "src/service/create-user.ts": [
          `import { userIdFromName, type User, type UserInput } from "../domain/user"`,
          ``,
          `export function createUser(input: UserInput): User {`,
          `  return {`,
          `    id: userIdFromName(input.name),`,
          `    name: input.name,`,
          `    email: input.email,`,
          `    role: input.role ?? "member",`,
          `  }`,
          `}`,
          ``,
        ].join("\n"),
        "src/index.ts": `export { createUser } from "./service/create-user"\n`,
      },
      test: [
        `import { expect, test } from "bun:test"`,
        `import { createUser } from "./src/index"`,
        ``,
        `test("createUser normalizes id/name/email", () => {`,
        `  const user = createUser({`,
        `    name: "  Ada   Lovelace  ",`,
        `    email: " Ada@Example.COM ",`,
        `  })`,
        ``,
        `  expect(user).toEqual({`,
        `    id: "ada-lovelace",`,
        `    name: "Ada Lovelace",`,
        `    email: "ada@example.com",`,
        `    role: "member",`,
        `  })`,
        `})`,
        ``,
      ].join("\n"),
    },
    {
      name: "workspace-source-filtering",
      description:
        "Repair workspace file filtering utilities so source file discovery excludes declaration/build/test artifacts across normalized paths.",
      files: {
        "tsconfig.json": `{"compilerOptions":{"strict":true},"include":["src"]}`,
        "src/fs/path.ts": [
          `export function normalizePath(input: string): string {`,
          `  return input.replaceAll("\\\\", "/")`,
          `}`,
          ``,
          `export function isSourceFile(file: string): boolean {`,
          `  return file.endsWith(".ts") || file.endsWith(".tsx")`,
          `}`,
          ``,
        ].join("\n"),
        "src/fs/filter.ts": [
          `import { isSourceFile, normalizePath } from "./path"`,
          ``,
          `export function sourceFiles(files: string[]): string[] {`,
          `  return files`,
          `    .map(normalizePath)`,
          `    .filter(isSourceFile)`,
          `    .filter((file) => !file.includes("/test/"))`,
          `}`,
          ``,
        ].join("\n"),
        "src/index.ts": `export { sourceFiles } from "./fs/filter"\n`,
      },
      test: [
        `import { expect, test } from "bun:test"`,
        `import { sourceFiles } from "./src/index"`,
        ``,
        `test("sourceFiles returns only production source files", () => {`,
        `  const files = [`,
        `    "src/index.ts",`,
        `    "src/components/button.tsx",`,
        `    "src/types.d.ts",`,
        `    "src/test/helpers.ts",`,
        `    "dist/index.ts",`,
        `    "coverage/lcov.ts",`,
        `    "src\\\\feature\\\\page.ts",`,
        `  ]`,
        ``,
        `  expect(sourceFiles(files)).toEqual([`,
        `    "src/index.ts",`,
        `    "src/components/button.tsx",`,
        `    "src/feature/page.ts",`,
        `  ])`,
        `})`,
        ``,
      ].join("\n"),
    },
    {
      name: "http-retry-policy",
      description:
        "Fix retry behavior in network utilities: non-retryable 4xx HTTP errors must fail fast, while retryable statuses should retry until success.",
      files: {
        "src/net/error.ts": [
          `export class HttpError extends Error {`,
          `  constructor(public readonly status: number, message: string) {`,
          `    super(message)`,
          `  }`,
          `}`,
          ``,
        ].join("\n"),
        "src/net/retry.ts": [
          `import { HttpError } from "./error"`,
          ``,
          `export async function withRetry<T>(fn: () => Promise<T>, maxAttempts = 3): Promise<T> {`,
          `  let lastError: unknown`,
          ``,
          `  for (let attempt = 1; attempt <= maxAttempts; attempt++) {`,
          `    try {`,
          `      return await fn()`,
          `    } catch (error) {`,
          `      lastError = error`,
          `      if (error instanceof HttpError && error.status < 500 && error.status !== 429) {`,
          `        // BUG: this should fail fast, but current code keeps retrying`,
          `      }`,
          `    }`,
          `  }`,
          ``,
          `  throw lastError`,
          `}`,
          ``,
        ].join("\n"),
        "src/index.ts": [
          `export { HttpError } from "./net/error"`,
          `export { withRetry } from "./net/retry"`,
          ``,
        ].join("\n"),
      },
      test: [
        `import { expect, test } from "bun:test"`,
        `import { HttpError, withRetry } from "./src/index"`,
        ``,
        `test("withRetry fails fast for non-retryable 4xx errors", async () => {`,
        `  let calls = 0`,
        `  await expect(`,
        `    withRetry(async () => {`,
        `      calls += 1`,
        `      throw new HttpError(400, "bad request")`,
        `    }),`,
        `  ).rejects.toThrow("bad request")`,
        `  expect(calls).toBe(1)`,
        `})`,
        ``,
        `test("withRetry retries retryable errors until success", async () => {`,
        `  let calls = 0`,
        `  const value = await withRetry(async () => {`,
        `    calls += 1`,
        `    if (calls < 3) throw new HttpError(503, "try again")`,
        `    return "ok"`,
        `  })`,
        ``,
        `  expect(value).toBe("ok")`,
        `  expect(calls).toBe(3)`,
        `})`,
        ``,
      ].join("\n"),
    },
    {
      name: "cache-ttl-and-eviction",
      description:
        "Fix cache expiration and capacity behavior in the store implementation so TTL cleanup always runs and oldest entries are evicted only when over cap.",
      files: {
        "src/cache/store.ts": [
          `export type Entry<T> = {`,
          `  value: T`,
          `  expiresAt: number`,
          `  touchedAt: number`,
          `}`,
          ``,
          `export class CacheStore<T> {`,
          `  private entries = new Map<string, Entry<T>>()`,
          ``,
          `  constructor(`,
          `    private readonly now: () => number,`,
          `    private readonly maxEntries = 100,`,
          `  ) {}`,
          ``,
          `  set(key: string, value: T, ttlMs: number) {`,
          `    const current = this.now()`,
          `    this.entries.set(key, { value, expiresAt: current + ttlMs, touchedAt: current })`,
          `    this.sweepExpired()`,
          ``,
          `    if (this.entries.size > this.maxEntries) {`,
          `      const oldest = [...this.entries.entries()].sort((a, b) => a[1].touchedAt - b[1].touchedAt)[0]`,
          `      if (oldest) this.entries.delete(oldest[0])`,
          `    }`,
          `  }`,
          ``,
          `  get(key: string): T | undefined {`,
          `    const entry = this.entries.get(key)`,
          `    if (!entry) return undefined`,
          ``,
          `    if (entry.expiresAt <= this.now()) {`,
          `      this.entries.delete(key)`,
          `      return undefined`,
          `    }`,
          ``,
          `    entry.touchedAt = this.now()`,
          `    return entry.value`,
          `  }`,
          ``,
          `  size(): number {`,
          `    return this.entries.size`,
          `  }`,
          ``,
          `  sweepExpired() {`,
          `    if (this.entries.size <= this.maxEntries) return`,
          `    const current = this.now()`,
          `    for (const [key, entry] of this.entries) {`,
          `      if (entry.expiresAt <= current) this.entries.delete(key)`,
          `    }`,
          `  }`,
          `}`,
          ``,
        ].join("\n"),
        "src/index.ts": `export { CacheStore } from "./cache/store"\n`,
      },
      test: [
        `import { expect, test } from "bun:test"`,
        `import { CacheStore } from "./src/index"`,
        ``,
        `test("sweepExpired removes expired entries even when below max size", () => {`,
        `  let now = 0`,
        `  const cache = new CacheStore<string>(() => now, 5)`,
        ``,
        `  cache.set("a", "A", 10)`,
        `  cache.set("b", "B", 20)`,
        `  now = 30`,
        ``,
        `  cache.sweepExpired()`,
        `  expect(cache.size()).toBe(0)`,
        `})`,
        ``,
        `test("cache evicts least recently touched entry only when over cap", () => {`,
        `  let now = 0`,
        `  const cache = new CacheStore<string>(() => now, 2)`,
        ``,
        `  cache.set("a", "A", 1000)`,
        `  now = 1`,
        `  cache.set("b", "B", 1000)`,
        `  now = 2`,
        `  cache.get("a")`,
        `  now = 3`,
        `  cache.set("c", "C", 1000)`,
        ``,
        `  expect(cache.get("a")).toBe("A")`,
        `  expect(cache.get("b")).toBeUndefined()`,
        `  expect(cache.get("c")).toBe("C")`,
        `})`,
        ``,
      ].join("\n"),
    },
  ]
}

